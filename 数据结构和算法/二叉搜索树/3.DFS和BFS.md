# 概念

## BFS：广度优先搜索

简单的说，BFS 是从根节点开始，沿着树的宽度遍历树的节点，如果发现目标，则演算终止。

## DFS：深度优先搜索

简单来说，从根节点出发，然后依次向下继续搜索，直到遇到叶子节点，此时就会向上回溯，继续向为访问过的点继续深度搜索。

# 题目

## 二叉树的最大深度 ⭐

题目描述：给定一个二叉树，找出其最大深度。

二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。

### 递归思路

- 每次分别遍历左节点,以及右节点,然后对比两者,取最大值
- 这样子，每次递归的话，深度都加 1

```js
function maxDeepth(root) {
  if (!root) return 0;
  return Math.max(maxDeepth(root.left), maxDeepth(root.right)) + 1;
}
```

### 非递归思路

- 使用 BFS，广度优先遍历
- 每一次用一个数组 temp 保存上一层的所有节点，每次计数器 count+1
- 当 temp 为空的时候，也就是此时都是叶子节点情况

```js
function maxDepth(root) {
  if (!root) return 0;
  let stack = [root];
  let count = 0;
  while (stack.length) {
    let temp = [];
    stack.forEach((item) => {
      item.left && temp.push(item.left);
      item.right && temp.push(item.right);
    });
    count += 1;
    stack = temp;
  }
  return count;
}
```

## 二叉树的最小深度 ⭐

给定一个二叉树，找出其最小深度。

最小深度是从根节点到最近叶子节点的最短路径上的节点数量。

### 递归思路：

- 如果 root 节点不存在，则深度为 0
- 如果 root 节点存在，但是左右节点均为 null，则深度为 1
- 如果当前节点的左节点不为 null，则找左子树的深度
- 如果当前节点的右节点不为 null，则找右子树的深度
- 比较 3 和 4 返回值，返回最小值 + 1

```js
function minDepth(root) {
  if (!root) {
    return 0;
  }
  let depth = 1;
  if (root.left && root.right) {
    const left = minDepth(root.left);
    const right = minDepth(root.right);
    depth += Math.min(left, right);
  } else if (root.left) {
    depth += minDepth(root.left);
  } else if (root.right) {
    depth += minDepth(root.right);
  }
  return depth;
}
```

### 非递归思路：

- 遍历这个树的每一层,当这个一层级的节点都没有左右节点时,直接返回结果
- 遍历每一层的节点,当这个 stack 种,某个节点的左右节点都是空时,即找到目标节点。

```js
function minDepth(root) {
  if (!root) {
    return 0;
  }
  let stack = [root];
  let depth = 0;
  while (stack.length) {
    let temp = [];
    depth++;
    stack.forEach((item) => {
      if (item.left === null && item.right === null) {
        return depth;
      }
      if (item.left) {
        temp.push(item.left);
      }
      if (item.right) {
        temp.push(item.right);
      }
      stack = temp;
    });
  }
  return depth;
}
```
