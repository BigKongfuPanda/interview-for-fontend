[【前端词典】继承（一） - 面试官问的你都会吗？](https://juejin.im/post/5c335940f265da610e804097)
[深入JavaScript系列（六）：原型与原型链](https://juejin.im/post/5c218e4c5188254caf18bb1a)

# 原型

每个函数（构造函数）都有一个 prototype 属性，指向该函数（构造函数）的原型对象。实例没有 prototype 属性，但是有 `__proto__` 属性。函数同时有 prototype 和 `__proto__` 属性。

```js
function Person(name) {
  this.name = name;
}

let person = new Person('xiaoming');

person.__proto__ === Person.prototype; // true

// 因为函数也是对象，所以也有 __proto__ 属性，指向 Function.prototype
Person.__proto__ === Function.prototype //true
```

由字面量创建的普通对象是Object的实例，
由 function 关键字声明的函数是Function的实例

```js
let obj = {};
obj.__proto__ === Object.prototype; // true

function fn() {};
fn.__proto__ === Function.prototype; // true
```

`__proto__` 属性虽然在ECMAScript 6语言规范中标准化，但是不推荐被使用，现在更推荐使用`Object.getPrototypeOf`，`Object.getPrototypeOf(obj)` 也可以获取到obj对象的原型。

```js
Object.getPrototypeOf(person) === person.__proto__; // true
```

# 原型链

当访问一个对象的属性时，先在对象的本身找，找不到就去对象的原型上找，如果还是找不到，就去对象的原型（原型也是对象，也有它自己的原型）的原型上找，如此继续，直到找到为止，或者查找到最顶层的原型对象中也没有找到，就结束查找，返回 undefined。

**这条由对象及其原型组成的链就叫做原型链**。

**原型链存在的意义就是继承**：访问对象属性时，在对象本身找不到，就在原型链上一层一层找。说白了就是一个对象可以访问其他对象的属性。

**继承存在的意义就是属性共享**：好处有二：一是代码重用，字面意思；二是可扩展，不同对象可能继承相同的属性，也可以定义只属于自己的属性

# 原型链的顶端

## Object 类型

**`Object.prototype.__proto__` 是原型链的顶端了，指向 null**。

```js
let obj = {};
obj.__proto__ === Object.prototype; //true
Object.prototype.__proto__ === null; //true
```

## Function 类型

对象都是被构造函数创建的，函数对象的构造函数就是 Function ，注意这里 F 是大写。

函数的最大的构造函数为 Function，其也有 prototype 属性，由于 `Function.prototype` 为一个对象，**所以 `Function.prototype.__proto__` 指向 `Object.prototype`**。

```js
Array.__proto__ === Function.prototype; //true
Object.__proto__ === Function.prototype; // true
```

同时，**由于 Function 也是一个对象，所以其也有 `__proto__` 属性，规定其属性指向 `Function.prototype`**。

```js
function fn() {};
fn.__proto__ === Function.prototype;
Function.prototype.__proto__ === Object.prototype; // true
Function.__proto__ === Function.prototype; // true
```

![原型链完整图示](https://user-gold-cdn.xitu.io/2018/11/9/166f859ad7cc4b0b?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

# instanceOf 的原理

作用：判断实例对象与构造函数之间是否为继承关系
原理：判断实例对象的 `__proto__` 属性和构造函数的 prototype 属性，是否为同一个引用。
注意点：如果存在多层继承关系，instanceof 会一直沿着原型链往上找。

```js
function Person () {};
let person = new Person();
person instanceof Person; // true
person instanceof Object; // true

person.__proto__ === Person.prototype; // true
Person.prototype.__proto__ === Object.prototype; // true
```

由上面可以看出，如果用 instanceof 是无法准确的判断出实例对象是否直接继承自该构造函数。此时需要使用 constructor。

```js
person.__proto__.constructor === Person; // true
person.__proto__.constructor === Object; // false
```

# 总结：

- `Object.prototype.__proto__ === null`；
- `Array.__proto__ === Function.prototype`；
- `Object.__proto__ === Function.prototype`；
- `Function.prototype.__proto__ === Object.prototype`；
- `Function.__proto__ === Function.prototype`；
- instanceof 不能准确的判断实例是否直接继承于构造函数