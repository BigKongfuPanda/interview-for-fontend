- react 中事件是合成事件，都代理到了 document 上面
- react 对 DOM 原生事件进行重写的原因是：性能（react 的 vDom 是批量更新，使用事件委托机制更合适）和复用（跨平台，跨浏览器）
- 合成事件的机制分为：注册和分发。React 并不会把所有的处理函数直接绑定在真实的节点上。而是把所有的事件绑定到结构的最外层，使用一个统一的事件监听器，这个事件监听器上维持了一个映射来保存所有组件内部的事件监听和处理函数。当组件挂载或卸载时，只是在这个统一的事件监听器上插入或删除一些对象。当事件发生时，首先被这个统一的事件监听器处理，然后在映射里找到真正的事件处理函数并调用。
- React 中合成事件的 e.stopPropagation() 是自己定义的一个函数，和原生事件的 stopPropagation 没有任何联系，所以自然无法阻止原生事件的冒泡。如果在 react 的合成事件中调用 e.nativeEvent.stopImmediatePropagation() ，其实是阻止了 document 上面同类事件的执行。
- 原生事件执行总是先于合成事件？这种情况只在给 非 document, window 元素 ` 添加原生事件时成立，当给 document 添加原生事件时，还取决于添加原生事件的时机: 1）在 render 之前添加原生事件，那么原生事件先于合成事件绑定，触发时先执行原生事件。2）在 render 之后比如 componentDidMounted 中,那么合成事件先于原生事件绑定,触发时先执行合成事件。
